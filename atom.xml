<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://chloeeew.github.io</id>
    <title>Chloe&apos;s Notebook</title>
    <updated>2021-10-10T08:12:36.628Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://chloeeew.github.io"/>
    <link rel="self" href="https://chloeeew.github.io/atom.xml"/>
    <subtitle>Though not be given a head start, but trying to stand out from my peers.</subtitle>
    <logo>https://chloeeew.github.io/images/avatar.png</logo>
    <icon>https://chloeeew.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Chloe&apos;s Notebook</rights>
    <entry>
        <title type="html"><![CDATA[Java Grammar for Automation Testing]]></title>
        <id>https://chloeeew.github.io/post/java-grammar-for-automation-testing/</id>
        <link href="https://chloeeew.github.io/post/java-grammar-for-automation-testing/">
        </link>
        <updated>2021-10-07T08:03:04.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p>工作需要最近开始要捡起Java并且搭建Selenium为其基础的自动化测试框架，后续有一系列相关笔记，笔记都是英文也是为世所迫（工作需要也得捡起英语），拙劣英文的请见谅<br>
Please excuse my English since I picked them up just a very short period of time.</p>
<h1 id="java-grammar">Java Grammar</h1>
<h3 id="first-java-grammar">First Java Grammar</h3>
<pre><code class="language-java">public class HelloWorld{
    public static void main(String[] args){
        System.out.println(&quot;Hello World&quot;);
    }
}
</code></pre>
<h3 id="basic-grammar">Basic Grammar</h3>
<ul>
<li>Sensible for Uppercase and Lowercase</li>
<li>Class name must be capitalized the first letter</li>
<li>Method name must be all lowercases</li>
<li>Source file name must be the same as Class name</li>
<li>All Java program start from main method(refer public static void main(String[] args) in particular)</li>
</ul>
<p>add package declaration on the top of the code to indicate where the class lives</p>
<pre><code class="language-java">package com.example.java;

public class HelloWorld{
    public static void main(String[] args){
        System.out.println(&quot;Hello World&quot;);
    }
}
</code></pre>
<p>which means:  the HelloWorld.java is in the com\example\java\</p>
<hr>
<h3 id="java-se-8-api-documentation">Java SE 8 API Documentation</h3>
<ul>
<li>https://docs.oracle.com/javase/8/docs/api/</li>
<li>https://blog.csdn.net/weixin_44034328/article/details/103645460</li>
</ul>
<hr>
<h4 id="primitive-data-type">Primitive data type</h4>
<p>primitive data type names are all lowercase</p>
<ul>
<li>
<p>Number(In order to save memory, Number was divided into different types)</p>
<img src="C:\Users\Chloe_Wang1\AppData\Roaming\Typora\typora-user-images\image-20210909174412325.png" alt="image-20210909174412325" style="zoom: 67%;" />
<ul>
<li>
<p>Java class library includes helper classes (<em><strong>java.lang.Double</strong></em>) for each primitive</p>
</li>
<li>
<p>Helper classes support conversion and formatting tools</p>
<img src="C:\Users\Chloe_Wang1\AppData\Roaming\Typora\typora-user-images\image-20210909175829688.png" alt="image-20210909175829688" style="zoom:50%;" />
<pre><code class="language-java">double a = 123.4d;
Double b = new Double(a);
int c = b.byteValue();
float f = b.floatValue();
</code></pre>
</li>
<li>
<p>Primitive numeric variables <strong>default to 0</strong></p>
</li>
<li>
<p>How to get the maximum number of each type?</p>
<pre><code class="language-java">System.out.println(&quot;maximum：Byte.MAX_VALUE=&quot; + Byte.MAX_VALUE);  
</code></pre>
</li>
<li>
<p>for float and double, what you've store aren't exactly what you've store. So <em><strong><u>BigDecimal</u></strong></em> is specifically designed to take care of this precision problems.</p>
</li>
</ul>
<pre><code>double finalBill = (this.taxRate * 0.01 +1)*this.initialBill;
BigDecimal fb = BigDecimal.valueOf(finalBill).setScale(2, RoundingMode.HALF_UP);
</code></pre>
<ul>
<li>
<p>You have to add 'L' at the end of a long type value or otherwise, it would consider as an integer.</p>
<pre><code>long ll = 2147483648L;
</code></pre>
</li>
<li>
<p>You have to add 'F' or 'f' right after a float type value or otherwise, it would consider as an integer or double</p>
<pre><code>float ff = 2.0f;
</code></pre>
</li>
</ul>
</li>
<li>
<p>Character</p>
<ul>
<li>Single quotation mark contains one character(2 bit)</li>
</ul>
</li>
<li>
<p>booleans (true/false)</p>
</li>
</ul>
<p><u><em><strong>java is a statically typed language, so all variables must have their types declared</strong></em></u></p>
<pre><code class="language-java">int myVar 5;
</code></pre>
<ul>
<li>
<p>when type was declared, you can't change the type</p>
</li>
<li>
<p>use camel case to define the identifier(myVar)</p>
</li>
</ul>
<h4 id="conversion">Conversion</h4>
<ul>
<li>
<p>automatic convert: from low to high</p>
<pre><code>byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double 
</code></pre>
</li>
<li>
<p>force to convert</p>
<pre><code class="language-java">public static int[] printArray(double[] args){
    int[] result = new int[args.length];
    for (int i=0; i&lt; args.length;i++) {
    	// convert double to int by using (int) 
    	result[i] = (int)args[i];
    }
    return result;
}
</code></pre>
</li>
<li>
<p>use helper classes to convert</p>
<pre><code class="language-java">for (int i=0; i&lt; args.length;i++) {
    Double doubleHelp = new Double(args[i]);
    result[i] = doubleHelp.intValue();
}
</code></pre>
</li>
</ul>
<hr>
<h3 id="reference-data-type">Reference data type</h3>
<ul>
<li>
<p>String</p>
<ul>
<li>
<p><strong>Commonly Used Method</strong></p>
<ul>
<li>
<p><strong>equals()</strong> : compares this string to the specified object, return true or false.</p>
<pre><code class="language-java">public boolean equals(Object)
</code></pre>
</li>
<li>
<p>equalsIgnoreCase(): similar to equals(), but this one will ignore its upper case or lower case.</p>
<pre><code class="language-java">public boolean equalsIgnoreCase(String anotherString)
</code></pre>
</li>
<li>
<p><strong>replace()</strong>: replace substring of this string with replacement sequence</p>
<pre><code class="language-java">public String replace(CharSequence target,
                      CharSequence replacement)
</code></pre>
</li>
<li>
<p>contains() : return true if and only if this string contains the sub-string</p>
<pre><code class="language-java">public boolean contains(CharSequence s)
</code></pre>
</li>
<li>
<p>endsWith(): tests if this string ends with the specified string</p>
<pre><code class="language-java">public boolean endsWith(String suffix)
</code></pre>
</li>
<li>
<p>indexOf(): returns the index with this string of the first occurence of the specified string.</p>
<pre><code class="language-java">public int indexOf(String str)
</code></pre>
</li>
<li>
<p>split(): splits this string around matches of the given regular expression</p>
<pre><code class="language-java">public String[] split(String regex)
</code></pre>
</li>
<li>
<p>substring(): returns a string that is a substring of this string. the substring begins at the specified beginIndex and extends to the character at endIndex(but not including the endIndex).</p>
<pre><code class="language-java">public String substring(int beginIndex,
                        int endIndex)
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>StringBuffer</strong></p>
<ul>
<li>
<p>hundreds of good to use method that you can check it in API docs</p>
<pre><code class="language-java">StringBuffer ab1 = new StringBuffer();
StringBuffer ab2 = ab1.append(&quot;hello&quot;);
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Class</p>
</li>
<li>
<p>Array</p>
<ul>
<li>
<p>Array create a <u><em>continuous memory space</em></u></p>
</li>
<li>
<p>Characteristic: <strong>Fixed Length + Fixed Type</strong></p>
<ul>
<li>
<p>Initialized by fixed value</p>
</li>
<li>
<p>Dynamic initialization : all elements default value are 0\0.0\false\ ' ' \ null (it depends on the data type)</p>
<pre><code class="language-java">double[] dd = new double[5];
System.out.println(dd.length);
System.out.println(dd[2]);
// 5
// 0
</code></pre>
</li>
</ul>
</li>
<li>
<p>How to obtain elements in this array? How to change elements in this array? :  <strong>Bracket + Index</strong>(index number can not be a negative number)</p>
<pre><code class="language-java">int[] d = {1,2,3,4,5};
System.out.println(d[1]);
System.out.println(d[4]);
// 2 
// 5
d[3] = 100;
System.out.println(d[3]);
// 100
</code></pre>
</li>
<li>
<p>How to get the length of the array?: <strong>array.length</strong></p>
<pre><code>System.out.println(d.length);
// 5
</code></pre>
</li>
<li>
<p><em><strong>Common Exception to Array</strong></em>:</p>
<ul>
<li>java.lang.ArrayIndexOutOfBoundsException</li>
<li>java.lang.NullPointerException, which is often caused by null</li>
</ul>
</li>
<li>
<p>Pass as parameter:</p>
<pre><code class="language-java">public static void printArray(double[] args){
    for (double arg : args) {
        System.out.println(arg);
    }
}
public static void main(String[] args) {
    // the 1st way
    double[] myList = {1.9, 2.9, 3.4, 3.5};
    printArray(myList);
    // the 2nd way
    printArray(new double[]{2,3,4,5,6});
}
</code></pre>
</li>
<li>
<p>Multidimensional Array</p>
<pre><code class="language-java">type[][] typeName = new type[typeLength1][typeLength2];
</code></pre>
</li>
</ul>
</li>
<li>
<p>enum</p>
</li>
<li>
<p>Interface</p>
</li>
</ul>
<h4 id="two-dimensional-array">Two-Dimensional Array</h4>
<ul>
<li>Create Statically
<ul>
<li><code>DataType[][] varName = {{..},{..},{..},..};</code></li>
</ul>
</li>
<li>Create Dynamically
<ul>
<li>The sub-array in this array is uncertain(if initialize, you have to initialize every sub-array): <code>DataType[][] varName = new DataType[size</code>][]</li>
<li>The sub-array is certain: <code>DataType[][] varName = new DataType [size] [size]</code></li>
</ul>
</li>
</ul>
<pre><code class="language-java">// In this case [0]=null
String[][] ss = new String[3][]
// Initialize
ss[0] = new String[3]
// sub-array is certain
String[][] tt = new String[3][2]
</code></pre>
<h4 id="precaution-to-reference-data-type">Precaution to reference data type</h4>
<ul>
<li>they all store address value(location info) in memory</li>
</ul>
<pre><code class="language-java">int[] d = {1,2,3,4,5};
System.out.println(d);
// [I@1b6d3586
</code></pre>
<ul>
<li><strong>null</strong> can be assigned to any reference type: you can output the variable, but you can not use this variable</li>
</ul>
<h4 id="java-provide-reference-data-type-to-almost-every-primitive-data-type">Java Provide Reference data type to almost every primitive data type</h4>
<table>
<thead>
<tr>
<th style="text-align:center">primitive type</th>
<th style="text-align:center">reference type</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">Boolean</td>
</tr>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">Byte</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">Character</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">Short</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">Integer</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">Long</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">Float</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">Double</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="process-control">Process Control</h2>
<h4 id="control">Control</h4>
<ul>
<li>
<p>Switch</p>
<ul>
<li>Data types that can be accepted by case are limited
<ul>
<li>int / byte / char / short / String / enum</li>
</ul>
</li>
</ul>
<pre><code>String dd = &quot;Chloe&quot;;
switch (dd){
    case &quot;chloe&quot;:
        System.out.println(&quot;111&quot;);
        break;
    case &quot;Chloe&quot;:
        System.out.println(&quot;3233&quot;);
        break;
    default:
        System.out.println(&quot;0000&quot;);
        break;
}
</code></pre>
<ul>
<li>pros: <strong>good performance</strong></li>
</ul>
</li>
<li>
<p>if..else if..else</p>
<ul>
<li>multiple branches</li>
<li>branches are mutually exclusive</li>
</ul>
</li>
</ul>
<h4 id="loop">Loop</h4>
<ul>
<li>
<p>for</p>
<ul>
<li>
<p>enhanced loop</p>
</li>
<li>
<p>normal loop</p>
<ul>
<li>
<p>multiple arguments</p>
<pre><code class="language-java">for(int i=A.lenth()-1,j=0;i&gt;=0;i--,j++){
            if(mm.charAt(i)!=mm.charAt(j)){
                System.out.println(&quot;dddd&quot;);
        }
</code></pre>
</li>
</ul>
</li>
<li>
<p>Nested loops</p>
</li>
<li>
<p>We used to loop array by the old method, but JDK 1.5 introduced a new loop method(what we call &quot;<strong>For-Each Loop</strong>&quot;). In this situation, intelliJ is deprecating the old loop method</p>
</li>
</ul>
<pre><code class="language-java">double[] myList = {1.9, 2.9, 3.4, 3.5};
	// old loop method
    for(int i=0;i&lt;myList.length;i++){
    System.out.println(myList[i]);
    }
    // new loop method
    for(double myElement:myList){
    System.out.println(myElement+&quot; eee&quot;);
    }
</code></pre>
</li>
<li>
<p>while</p>
<ul>
<li><code>while(condition statement){statement1;}</code></li>
<li><code>do{}while(condition)</code></li>
</ul>
</li>
</ul>
<h2 id="functionmethod">Function(Method)</h2>
<ul>
<li>There's no run order between each Function in the same Class</li>
</ul>
<h4 id="common-type">Common Type</h4>
<ul>
<li>
<p>common method</p>
<ul>
<li>format: <code>Modifier ReturnType MethodName(parameter list){Method Body}</code></li>
</ul>
<pre><code class="language-java">public static int age(int birthday){...}
</code></pre>
</li>
<li>
<p><strong>overload method</strong></p>
<ul>
<li>Definition: In the same class, you can create a method with <strong>the same method name</strong> that already hava <strong>but with different parameter types</strong> as an over load method. (ps: There's nothing to do with return type)</li>
</ul>
<pre><code class="language-java">public static void main(String[] args) {
    System.out.println(add(2));
    System.out.println(add(2,3));
    System.out.println(add(2.3d,2));
}
public static int add(int a, int b){
    return a+b;
}
public static double add(double a, double b){
    return a+b;
}
public static int add(int a){
    return 1+a;
}
// output: 3\5\4.3
</code></pre>
<ul>
<li>Uses: Reduce the memory of different method, it's convenient for caller</li>
</ul>
</li>
<li>
<p><strong>Override method</strong></p>
<ul>
<li>Condition of use: Inheritance or Polymorphism</li>
<li>Pros: upgrade old method</li>
<li>Optional(for calibration): you can add &quot;<code>@Override</code>at the top of the method, which is to check if it is a override method(if it isn't, then IDE will throw an exception)</li>
<li>How can I call the method with the same name of parent class? : by using key word <code>super</code> (but you can't find grandparent's class)</li>
</ul>
<pre><code class="language-java">public class IPhone4S extends IPhone{
    public void Siri(){
        System.out.println(&quot;111&quot;);
    }
}

public class IPhone5 extends IPhone4{
    @Override
    public void Siri(){
        super.Siri();
        System.out.println(&quot;222&quot;);
    }
}
</code></pre>
</li>
<li>
<p><strong>Construct method</strong></p>
<ul>
<li>Used for constructing a new object</li>
<li>format:<code>public void ClassName(){}</code>
<ul>
<li>you can omit return data type, because construct method must return null</li>
</ul>
</li>
<li>constuct method can be a overload method</li>
<li>One thing to note is that when passing parameters into construct method, and your parameter name is the same with the variable name in class, you should use &quot;<mark>this</mark>&quot; to distinguish them(local variables and member variables).</li>
</ul>
<pre><code class="language-java">public class Calculator {
String name;
int age;
public Calculator(String name,int age){
    this.name = name;
    this.age = age;
}
public void PrintOut(){
    System.out.println(this.name);
    System.out.println(this.age);
}
}


public static void main(String[] args) {
      Calculator cc = new Calculator(&quot;aaa&quot;,3);
      cc.PrintOut();
}
// output:aaa 3      
</code></pre>
</li>
<li>
<p>Abstract method</p>
<ul>
<li>abstract method define a prototype of a method, it doesn't implement any specific rules</li>
<li>shows in Interface</li>
</ul>
</li>
</ul>
<hr>
<h2 id="objectobject-oriented">Object(Object-Oriented)</h2>
<ul>
<li>
<p>Diffrence between Object and Class</p>
<ul>
<li>Class is just like a template, describe something or some action with common.<strong>(Abstract)</strong>
<ul>
<li>a mobile phone, which be able to take a call and message. Define phone's brand, price and tag.</li>
</ul>
</li>
<li>Object describes something or some actions from class more specific
<ul>
<li>apple mobile phone, which has specific price tag, phone size, os characteristic and so on.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Instantiate Object(Create an object)</p>
<ul>
<li><code>ClassName ObjectName = new ClassName()</code></li>
</ul>
<pre><code class="language-java">Calculator cc = new Calculator();
</code></pre>
</li>
<li>
<p><strong>Three Characteristic in Object: Encapsulation, Polymorphism, Inheritance</strong></p>
<ul>
<li>
<p>Encapsulation: which enhance the readability and maintainability of code</p>
<ul>
<li>limit the modification of object's variable</li>
</ul>
<pre><code class="language-java">Public Class Calculator{
    private String name; // You won't have any access unless you visit it by method in the same class.
    
    public void setName(String name){
        this.name = name
    }
    
    public String getName(){
        return this.name
    }
    
}
</code></pre>
</li>
<li>
<p>Inheritance: if A class inherit B class, then A class owns all public method of B class.</p>
<ul>
<li>use &quot;<strong>extends</strong>&quot; to inherit</li>
</ul>
<pre><code class="language-java">public class People {
    private String name;
    private int age;

    public int getAge(){
        return this.age;
    }
    public String getName(){
        return this.name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public void setName(String name) {
        this.name = name;
    }
}

public class Engineer extends People{
}

public class InheritDemo {
    public static void main(String[] args) {
        Engineer ee = new Engineer();
        ee.setAge(23);
        System.out.println(ee.getAge());
    }
}
// 23
</code></pre>
<ul>
<li>if a class do not inherit from other class, then it will automatically inherit Object class by default(ancestor class)</li>
<li>class can inherit only one class, but class can be inherited by multiple classes.<strong>(Single Inheritance)</strong></li>
<li>could not inherit any private members of parent class</li>
<li>when create object from a child class, java will call the construct method of its parent class at the beginning.</li>
</ul>
</li>
<li>
<p>Polymorphism</p>
<ul>
<li>
<p>Receive objects of subclasses with the type of the parent class</p>
</li>
<li>
<p>the same method that can be perform in different action accroding to their different morphology(example:Human and Monkey, they're all inherit Creature).</p>
</li>
<li>
<p>in the condition of inheritance</p>
</li>
<li>
<p>It reflects scalability</p>
<pre><code class="language-java">ParentClass variableName = new ChildClassName();
</code></pre>
<ul>
<li>
<p>Pros: able to accept all sub-classes object by only one parent class variable.</p>
</li>
<li>
<p>However, in this situation, <strong>you can not call the unique method of Child Class</strong>. So, you can only call the method shared by both parent class and child class, which should be an override method that overridden by child class.</p>
<ul>
<li>
<p>How can I call the unique method of child class? : Forced Conversion</p>
<pre><code class="language-java">Card card = new ACard();
ACard aCard = (ACard)card;
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="modifier">Modifier</h2>
<h4 id="access-modifier">Access Modifier</h4>
<ul>
<li><strong>public</strong> : you can access in any case</li>
<li><strong>protected</strong>: you can access when you inherit the class(wherever the package is)</li>
<li><strong>default</strong> : you can access in the same package(it means in the same folder).</li>
<li><strong>private</strong> : you can access in the same class.</li>
</ul>
<h4 id="non-access-modifier">Non-Access Modifier</h4>
<ul>
<li>static : you can call it without instantiate an object</li>
<li>final : you can not overwrite this method/class (Format is as follows)</li>
</ul>
<p>public static final String ECOMMERCE_URL = &quot;http://automationpractice.com/index.php&quot;;</p>
<pre><code>
- abstract : use for setting a initial mehtod, then refine the method by rewriting it.

---

## Collection

*Container is use for storing data*

- **ArrayList** : Resizable-array, the actual realization is to create a new array for the sake of expansion

  - When instantiate, it constructs an empty list with an initial capacity of 10.

  - You have to regulate the data type of this collection(That's what we call **Generics&lt;&gt;**), and this data type must be **reference data type**. Java do not recommend you to ignore the specific data type in this collection.

  - **Collection Polymorphism** : use Interface as a datatype(No difference, but to remember that you can not instantiate that Interface)

    ```java
    List&lt;String&gt; list1 = new ArrayList&lt;&gt;();
    ```
    
  - Usage example:

    ```java
    public static void main(String[] args) {
            // not recommend you to do so
            // ArrayList al = new ArrayList(); // it turns out you add multiple object in al
    
            // this is the preferable one
            ArrayList&lt;String&gt; al = new ArrayList&lt;&gt;();
            // or ArrayList&lt;String&gt; al = new ArrayList&lt;String&gt;();
    
            al.add(&quot;ccc&quot;);
            al.add(&quot;ddd&quot;);
            al.add(&quot;ooo&quot;);
    
            System.out.println(al); // ToString() has been overwritten by ArrayList
            // output:[ccc, ddd, ooo]
        }
    ```
    
  - Commonly used method:

    - **add()** : append specified element to the end of the list
    - addAll() : append all the element in the specified collection to the end of the list
    - **get()**: Returns the element at the specified position in this list.
    - **size()**: Returns the number of elements in this list.
    - isEmpty(): Returns `true`if this list contains no elements.
    - remove() : Removes the element at the specified position in this list. or Removes the first occurrence of the specified element from this list, if it is present.(Overload method)
    - set() : Replaces the element at the specified position in this list with the specified element.

  - 3 types of loop

    - by index

      ```java
      for(int i=0;i&lt;al.size();i++){
                  System.out.println(al.get(i));
              }
      ```

    - by enhanced loop

      ```java
      for(String a:al){
                  System.out.println(a);
              }
      ```

    - by iterator (not every container has index, then iterator appeared) --- less important

      ```java
      Iterator&lt;String&gt; ial = al.iterator();
              while(ial.hasNext()){
                  System.out.println(ial.next());
              }
      ```

- HashSet: Unordered(just not in order of the addition, they calculate the order by their own algorithm), no index, **non-repeatable**. 

  - Usage example:

    ```java
    HashSet&lt;String&gt; al = new HashSet&lt;&gt;();
    
    al.add(&quot;ccc&quot;);
    al.add(&quot;ddd&quot;);
    al.add(&quot;ooo&quot;);
    al.add(&quot;22&quot;);
    al.add(&quot;ddd&quot;);
    
    System.out.println(al); // Output:[22, ccc, ddd, ooo]
    ```

  - **Collection Polymorphism** : use Interface as a datatype(No difference, but to remember that you can not instantiate that Interface)

    ```java
    Set&lt;String&gt; set1 = new HashSet&lt;&gt;();
    ```

  - Commonly used method  (HashSet and ArrayList are all inheriting from Collection, so most of their methods are similar to each other.)

    - add() : Adds the specified element to this set if it is not already present.(**if it is already present, then return false**)
    - remove() : Removes the **specified element** from this set if it is present.
    - size() : Returns the number of elements in this set (its cardinality).

  - Loop (no index in HashSet)

    - enhanced loop
    - iterator

- HashMap : store data in form of key-value pairs, but key shouldn't be the same. 

  - `HashMap&lt;k,v&gt; varName = new HashMap&lt;k,v&gt;();`

  - key is unordered,no-index and non-repeatable

  - **Collection Polymorphism** : use Interface as a datatype(No difference, but to remember that you can not instantiate that Interface)

    ```java
    Map&lt;String,String&gt; map = new HashMap&lt;&gt;();

  - Commonly use method

    - get() : Returns the value to which the specified key is mapped, or `null` if this map contains no mapping for the key.  

      ```java
      HashMap&lt;String,Integer&gt; aa = new HashMap&lt;&gt;();
      aa.put(&quot;eee&quot;,22);
      aa.put(&quot;eer&quot;,34);
      System.out.println(aa); // {eer=34, eee=22}
      System.out.println(aa.get(&quot;eee&quot;)); //22
      ```

    - put() : Associates the specified value with the specified key in this map. If the map previously contained a mapping for the key, the old value is replaced.

      ```java
      public V put(K key,V value)
      ```

    - **containsKey()** : Returns `true` if this map contains a mapping for the specified key.(*Given the fact that key is non-repeatable*)

      ````
      public boolean containsKey(Object key)
      ````

    - getOrDefault() : Returns the value to which the specified key is mapped, or default Value if this map contains no mapping for the key.

      ```
      public V getOrDefault(Object key, V defaultValue)
      ```

    - **keySet()** : Set is implemented by HashSet, so Set is just like parent, and keySet() is child that implement Set.(You can not instantiate interface) 

      ```
      public Set&lt;K&gt; keySet()
      ```

      - Usage :  pair with get(key)

        ```
        Set&lt;String&gt; ss = aa.keySet();
        for(String s :ss){
        	System.out.println(s + &quot;=&quot; + aa.get(s));
        }
        ```

    - **entrySet()**: similar to dict.items() in Python

      - `public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()`

      - Implementation logic

        ```java
        class Entry{
        	K key;
        	V value;
        }
        ```

      - Usage

        ```java
        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = aa.entrySet();
                // or Set&lt;Entry&lt;String, Integer&gt;&gt; entries = aa.entrySet(); ( but you should import java.util.Map.Entry )
                for(Map.Entry&lt;String, Integer&gt; en:entries){
                    System.out.println(en.getKey() + &quot; == &quot; + en.getValue());
                }
            }
        ```

    - foreach() : loop method that similar to entrySet(), but is more convenient

      - `public void forEach(BiConsumer&lt;? super K,? super V&gt; action)`

      - Usage

        ```java
        aa.forEach((k,v)-&gt;{
                    System.out.println(k + &quot;==&quot; + v);
                });
        ```





---

## Interface

- Interface is a collection of abstract methods, you should overwrite every abstract method later on class which implemented the interface.

  ```java
  public interface BaBa{
      int size();
  }
  public class ArraryCheck implements BaBa{
      // overwrite size
      public int size(){
          return 1;
      }
  } 
</code></pre>
<ul>
<li>
<p>Similar with class, but somehow they're quite different:</p>
<ul>
<li>Interface can not be instantiated</li>
<li>There's no construct method in Interface</li>
<li>Interface is born to be impletemented</li>
<li>but unlike inheritance, multiple interfaces can be implemented.</li>
</ul>
</li>
<li>
<p>What's the similarities and differences between abstract class and interface?</p>
<ul>
<li>Similarities:
<ul>
<li>Both can not create an object.</li>
<li>Both contains abstract methods.</li>
</ul>
</li>
<li>differences:
<ul>
<li>abstract class embody commonality</li>
<li>interface embody characteristic</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Characteristic:</p>
<ul>
<li>Every method is a hidden abstract, which means they hide the modifier <strong>public abstract</strong></li>
<li>Every variable can be hidden, but the modifier of each variable should only be <strong>public static final</strong></li>
<li>You can not implement method in interface, but you can do it in class by implemented the interface.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="memory-mechanism">Memory Mechanism</h2>
<ul>
<li>Java put memory into two type:
<ul>
<li><strong>Stack Memory</strong>
<ul>
<li>Stack characteristic: First In Last Out(FILO)</li>
<li>pressing method or variable into the bottom of stack</li>
<li>Stack store the access address for heap memory space</li>
</ul>
</li>
<li><strong>Heap Memory</strong>
<ul>
<li>use for storing array and object create by &quot;new&quot;(every time you create an object, java allocates memory space from heap, which is pointed by stack memory)</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="keyboard-shortcut">Keyboard Shortcut</h2>
<ul>
<li>check files : double Shift</li>
<li>check the inherit relation: Ctrl + H</li>
<li>import: alt+Enter</li>
<li>input println : sout</li>
<li>input println with <code>Class name.Method name</code> : soutm</li>
<li>file formatting: Crtl+Alt+L</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[扫码支付都有哪些可测点？]]></title>
        <id>https://chloeeew.github.io/post/sao-ma-zhi-fu-du-you-na-xie-ke-ce-dian/</id>
        <link href="https://chloeeew.github.io/post/sao-ma-zhi-fu-du-you-na-xie-ke-ce-dian/">
        </link>
        <updated>2021-08-11T03:36:10.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>最近代码写多了，得锻炼一下测试思维！基本功不能掉！</p>
</blockquote>
<h2 id="扫二维码付款这个流程有哪些测试点">扫二维码付款这个流程，有哪些测试点？</h2>
<ul>
<li>使用到的测试用例设计方法：场景法+等价边界值</li>
<li>考虑角度：功能、界面、兼容、易用、安全、性能</li>
<li>特性测试：移动端与web端还需要考虑中断、弱网、权限允许、指纹面纹、触摸屏等</li>
</ul>
<h5 id="整个扫码付款过程场景">整个扫码付款过程场景：</h5>
<ol>
<li>商户卖家生成二维码，用户看到二维码后-&gt;</li>
<li>打开手机中存在支付功能的app进行扫码-&gt;</li>
<li>确认支付的金额-&gt;</li>
<li>点击支付-&gt;</li>
<li>选择支付方式（余额、零钱通、信用卡、储蓄卡、花呗等）-&gt;</li>
<li>输入支付密码（或面容支付）-&gt;</li>
<li>得到支付结果信息-&gt;</li>
<li>商家卖家得到收款信息-&gt;</li>
<li>（可能会有手续费以及退款操作）</li>
</ol>
<h3 id="0-冒烟">0、冒烟</h3>
<ul>
<li>扫二维码后是否出现支付页面</li>
<li>检查支付金额、商家和时间等信息</li>
<li>可选择的支付方式中余额充足</li>
<li>按照默认支付方式吊起面容或密码成功支付</li>
<li>返回给用户支付信息、订单号、商家、时间等信息正确</li>
<li>商家收到收款提示，余额增加，能查询到详细的首款</li>
</ul>
<h3 id="一-商户卖家生成二维码用户看到二维码后进行扫码">一、商户卖家生成二维码，用户看到二维码后进行扫码</h3>
<ul>
<li>二维码太大的情况下扫部分能否进入支付支付页面</li>
<li>二维码太小能否支付app主动放大去扫</li>
<li>过期了是否生成新的二维码</li>
<li>扫了过期的二维码能否还能支付</li>
<li>断网的情况下扫码</li>
<li>弱网（2G/3G）条件下扫码</li>
<li>扫码时人为中断操作（切换横竖屏、来消息提醒、插拔耳机、调节音量）是否影响跳转</li>
<li>是否支持多人一起扫（准备抢着买单）</li>
<li>是否支持不同支付app（不同版本）去扫相同的码</li>
<li>是否支持不同手机操作系统定制rom的兼容</li>
<li>能否扫多次，有没有最大扫码次数</li>
</ul>
<h3 id="二-扫码进入支付页面">二、扫码进入支付页面</h3>
<ul>
<li>如果是用户输入的话，检查输入内容（有没有限额，有则边界值、另外考虑金额的精度、是否能输入符号、中英文非数字）</li>
<li>如果是商户卖家决定的金额，能够篡改商户？是否能够篡改金额？</li>
<li>从不同应用或者中断后，返回支付页面</li>
</ul>
<h3 id="三-支付">三、支付</h3>
<ul>
<li>点击支付后吊起的弹窗金额是否等同支付页面金额（没有其他券、集分宝、红包的情况）</li>
<li>有券、集分宝和红包时，是否自动抵扣，实际支付金额是否等于支付页面金额-券金额-集分宝-红包</li>
<li>支付方式的顺序是否按照原先支付平台设定的顺序</li>
<li>商户不支持的支付方式是否置灰不允许点击（信用卡或花呗）</li>
<li>可选择的支付方式中余额不足（边界值）</li>
<li>可选择的支付方式中余额充足但超过了这个支付方式的单日限额或单笔限额</li>
<li>某支付方式因尝试超限额后，是否更新为置灰状态</li>
<li>若默认第一项支付方式无法支付，第二顺序的支付方式是否成为接下来的默认支付方式</li>
<li>实际支付金额、红包等金额是否能够篡改</li>
<li>支付方式的置灰能否篡改为可点击</li>
<li>中断切换到不同应用，返回支付页面是否正常</li>
<li>点击取消后，是否返回原未支付的状态</li>
</ul>
<h4 id="支付密码支付密码-支付面容">支付密码（支付密码、支付面容）</h4>
<ul>
<li>支付密码输入（面容）的最大尝试次数</li>
<li>支付密码未输入或输出错误后能否切换面容</li>
<li>关闭支付密码是否返回到支付方式选择中，状态仍为未支付</li>
<li>支付0元时，是否会吊起支付密码</li>
</ul>
<h4 id="支付中">支付中</h4>
<ul>
<li>断网支付</li>
<li>同一用户，弱网单次、重复多次相同订单号的支付</li>
<li>多个用户，同时支付同一个订单</li>
</ul>
<h4 id="支付成功">支付成功</h4>
<ul>
<li>支付成功后二维码的状态更新</li>
<li>支付成功后扫过期二维码</li>
<li>支付成功后用户断网（弱网），能否查询到支付历史</li>
<li>支付成功后商户断网（弱网），是否有收款提醒或收款历史</li>
</ul>
<h4 id="红包等抵扣金额">红包等抵扣金额</h4>
<ul>
<li>红包金额恰好等于支付金额</li>
<li>单个红包金额大于/小于需支付金额-边界值</li>
<li>多个红包金额加起来大于/小于需支付金额-边界值</li>
<li>红包金额抵扣后剩余0.01元</li>
<li>红包金额只抵扣了0.01元</li>
</ul>
<h4 id="支付失败">支付失败</h4>
<ul>
<li>支付失败二维码状态变化</li>
<li>支付失败扫旧的二维码</li>
<li>支付失败重新扫二维码</li>
</ul>
<h3 id="手续费">手续费</h3>
<ul>
<li>若存在手续费，明确哪些支付方式存在手续费，哪方扣除，以及手续费的计算公式。不该收受手续费的不应扣除任何一方手续费</li>
<li>收受手续费的，支付方式显示对应手续费费率，及得出计算后具体扣除多少手续费</li>
<li>实际支付金额= 原始金额+手续费-红包等抵扣金额
<ul>
<li>单笔手续费最小收取金额-边界值</li>
<li>原始金额时单笔最小金额，且手续费率收取为0.01%的情况</li>
<li>单笔手续费最大收取金额-边界值</li>
</ul>
</li>
</ul>
<h3 id="退款">退款</h3>
<ul>
<li>商户发起退款后，用户和商户原本的账单状态信息是否更新</li>
<li>原账单中发起退款的按钮是否容易被找到</li>
<li>退款后，用户返回金额为实际付款金额（发起金额-红包等可抵扣金额），若有手续费，手续费不退回</li>
<li>退款前若用户有使用券等，原路返回，但有效期与使用前有效期一致（退款后券的有效期结束，那么卷则返回到过期券中，不可使用）</li>
<li>退款后返回的可用券，应可再次被使用</li>
<li>退款后用户有收款信息</li>
<li>退款后商户有扣款信息</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关键字驱动的自动化测试]]></title>
        <id>https://chloeeew.github.io/post/guan-jian-zi-qu-dong-de-zi-dong-hua-ce-shi/</id>
        <link href="https://chloeeew.github.io/post/guan-jian-zi-qu-dong-de-zi-dong-hua-ce-shi/">
        </link>
        <updated>2021-07-22T09:12:07.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>除了数据驱动测试外，还有一个在自动化测试的驱动测试：关键字驱动，常用于在测试开发中</li>
<li>这样的关键字驱动让我想起robot framework也是也是以关键字驱动的自动化测试</li>
</ul>
<h4 id="数据驱动测试">数据驱动测试</h4>
<ul>
<li>测试逻辑和数据表（列表，excel表格，yaml表)存储下来</li>
<li>数据 --&gt;  自动化测试逻辑</li>
</ul>
<h2 id="关键字驱动测试">关键字驱动测试</h2>
<ul>
<li>分开测试<strong>数据、动作和操作</strong>
<ul>
<li>动作和操作以关键字的形式表现出来，例如click、find、find_element（偏测开了，可以直接在开发好的自动化系统中选择click）</li>
<li>动作、数据 -----&gt;自动化测试逻辑</li>
</ul>
</li>
</ul>
<pre><code>-
  action: &quot;goto&quot;
  params:
    url: &quot;https://v4.ketangpai.com/User/login.html&quot;
-
  action: &quot;fill&quot;
  params:
    locator: ['name', 'account']
    data: 'wagyu2017@163.com'
-
  action: &quot;fill&quot;
  params:
    locator: ['name', 'pass']
    data: 'admin123456'
-
  action: &quot;click&quot;
  params:
    locator: ['xpath', &quot;//div[contains(@class, 'pt-login')]/a[@class='btn-btn']&quot;]
-
  name: &quot;说明操作&quot;
  action: &quot;click&quot;
  params:
    locator: ['xpath', &quot;//*[text()='熟悉  课堂派']&quot;]
</code></pre>
<ul>
<li>关键字文件params中的参数要和实际方法形参命名相同</li>
<li>只需要编写一个测试用例就能够把所有操作执行</li>
</ul>
<pre><code>  from common.basepage import BasePage
import yaml
def test_case(get_driver):
    &quot;&quot;&quot;运行测试用例&quot;&quot;&quot;
    driver = get_driver
    d = BasePage(driver)
    # 打开关键字驱动的表，yaml
    file = r'D:\classes\web_auto_testing\lesson12\test_add_class.yaml'
    with open(file, encoding='utf-8') as f:
        steps = yaml.safe_load(f)
    for step in steps:
       # step = {&quot;action&quot;: &quot;goto&quot;, &quot;params&quot;:...}
       action = step['action']
       # 要使用的操作：goto, click, fill
       method = getattr(d, action)
       # 要使用的参数：url,  locator
       params = step['params']
       # 调用 basepage 的方法
       method(**params)

# 使用关键字驱动， test_case 是通用的。
</code></pre>
<h4 id="关键字驱动测试的好处">关键字驱动测试的好处</h4>
<ul>
<li>只需要维护表格就可以了，把动作分离出去了</li>
<li>实现了自动化测试的无代码化，所有的用例都可以用同一个测试代码块</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python 那些好用的函数（含高阶函数）]]></title>
        <id>https://chloeeew.github.io/post/python-na-xie-hao-yong-de-han-shu-han-gao-jie-han-shu/</id>
        <link href="https://chloeeew.github.io/post/python-na-xie-hao-yong-de-han-shu-han-gao-jie-han-shu/">
        </link>
        <updated>2021-07-15T02:03:32.000Z</updated>
        <content type="html"><![CDATA[<h1 id="匿名函数lambda">匿名函数lambda</h1>
<ul>
<li>简化函数的书写形式，适用于短小的函数</li>
</ul>
<pre><code>def f(num):return num + 1
# 可以简化写成lambda形式，用一个参数接收即可
g = lambda x: x + 1
print(g(1))
print(f(1))
# 运行结果都是2
</code></pre>
<ul>
<li>匿名函数的格式
<ul>
<li>lambda 参数1,参数2: 返回值</li>
</ul>
</li>
</ul>
<h2 id="应用场景">应用场景</h2>
<ul>
<li>sorted函数</li>
</ul>
<pre><code>sorted(iterable,key=None, reverse=False)
# key -- 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，
指定可迭代对象中的一个元素来进行排序。
# reverse -- 排序规则，reverse = True 降序 ， reverse = False 升序（默认）。
</code></pre>
<h4 id="实例">实例</h4>
<pre><code># 不经过lambda改良
def f(stu:dict):
    return stu['age']

def sort_test():
    students=[
        {'name':'feisdmx','age':85},
        {'name':'cfeid','age':20},
        {'name':'ppepr','age':50},
        {'name':'aaaeef的','age':26}
    ]
    print(sorted(students,key=f,reverse=True))

if __name__ == '__main__':
    sort_test()

# 经过lambda改良后
def sort_test():
    students=[
        {'name':'feisdmx','age':85},
        {'name':'cfeid','age':20},
        {'name':'ppepr','age':50},
        {'name':'aaaeef的','age':26}
    ]
    print(sorted(students,key=lambda stu:stu['age']))

if __name__ == '__main__':
    sort_test()        
</code></pre>
<h1 id="zip">zip</h1>
<ul>
<li>将多个可迭代对象按照索引值顺序，各自组成以元组对，函数返回值是迭代器<br>
<img src="https://chloeeew.github.io/post-images/1628215508684.png" alt="" loading="lazy"></li>
</ul>
<pre><code>a = ['a','b','c']
b = [1,2,3]
c = dict(zip(a,b))
------
{'a':1,'b':2,'c':3}
</code></pre>
<h1 id="递归">递归</h1>
<ul>
<li>通过递归的方法能够实现很多数学问题，如斐波那契数列等</li>
<li>注意：递归至少要确定最前或最后的那个常数项，接下来的按照数学规律递归即可</li>
</ul>
<h3 id="斐波那契数列">斐波那契数列</h3>
<pre><code>def fib(n):
    if n==1 or n==2:
        return 1
    return fib(n-1)+fib(n-2)

</code></pre>
<h3 id="实现累加功能从1加到100">实现累加功能从1加到100</h3>
<pre><code>def demo02(x=100):
    if x==1:   # 递归结束条件    
        return 1    # 结束递归
    return demo02(x-1) + x    # 递归调用
</code></pre>
<h3 id="一个球从100米高度自由落下每次落地后反跳回原高度的一半再落下求它在第十次落地时共经过了多少米">一个球从100米高度自由落下，每次落地后反跳回原高度的一半，再落下，求它在第十次落地时，共经过了多少米？</h3>
<pre><code>def free_fall(times):
    if times == 1:
        return 100
    return free_fall(times-1) + 100//2**(times-1) * 2
</code></pre>
<p><mark>使用递归的规律：把题目中的数学规律找出来，写出第n次的数学表达式，把常数项（第1项或最后1项，把数转换为常数去替换倒数第二次递归的函数返回值）找出来作为最后return的值</mark></p>
<h1 id="闭包">闭包</h1>
<ul>
<li>包：一个函数包着一个函数</li>
<li>闭： 操作函数中的局部变量的一种方法</li>
</ul>
<h4 id="nonlocal关键字用来在函数或其他作用域中使用外层非全局变量">nonlocal关键字用来在函数或其他作用域中使用外层(非全局)变量。</h4>
<pre><code>def 函数()：
    result = 0 # local变量 局部变量
    def 函数中的函数():
        nonlocal result
        result += 1
    return 函数中的函数   # 把函数返回

f = 函数()  # 返回值的类型是function     
# 那么可以通过f()去访问函数中的函数，通过f()操作后，result是没有被重置的  
</code></pre>
<ul>
<li>闭包可以实现数学中的y=ax+b，装饰器是闭包的一种</li>
</ul>
<pre><code>def line_def(a,b):
    def wrapper(x):
        return a*x+b
</code></pre>
<p><strong>闭包是一种编程思想：闭包打破了函数结束后资源全部销毁的情况，闭包能够保存函数仲某个变量的值</strong></p>
<h1 id="高阶函数">高阶函数</h1>
<ul>
<li>高阶函数是函数里面的参数是函数</li>
</ul>
<h2 id="map">Map</h2>
<ul>
<li>会根据提供的函数对指定序列做映射</li>
<li><strong>传递的参数是函数名字（函数实现比较简单的话，可以用匿名函数代替）  和可迭代对象</strong>，将可对迭代对象的每个值传递到指定函数中，并返回迭代器<br>
<img src="https://chloeeew.github.io/post-images/1628215520407.png" alt="" loading="lazy"></li>
</ul>
<pre><code>g = map(lambda x,y:{x:y},['a','b','c'],[1,2,3]) # 返回的是迭代器对象
print(next(g)) # 按照迭代器的方式输出第一个值，得到{'a'：1}
# 也可以通过for循环输出其他的映射值
for i in g:
    print(i)
</code></pre>
<ul>
<li>注意，函数的参数值个数，对应着后续可迭代对象的个数（函数形参有多少个，那么可迭代对象就要有多少个）</li>
</ul>
<pre><code>map(fuc(T1,T2,T3,T4),list1,list2,list3,list4)
</code></pre>
<h2 id="reduce">reduce</h2>
<ul>
<li>reduce方法接收一个function作为累积器，sequence中的每个值（从左到右）开始缩减，最终计算为一个值</li>
</ul>
<pre><code>from functools import reduce
</code></pre>
<h4 id="参数">参数</h4>
<pre><code>reduce(function, sequence)
</code></pre>
<h4 id="实例-2">实例</h4>
<pre><code>print(reduce(lambda x,y:x+y,range(1,101))) # 累加 从1加到1000
print(reduce(lambda x,y:x*y,range(1,5)))  # 累乘 1*2*3*4=24 
</code></pre>
<h2 id="filter">filter</h2>
<ul>
<li>可以按照函数名代表功能，过滤出给的可迭代对象，并返回一个迭代器</li>
</ul>
<pre><code>f = filter(lambda x:x&gt;5,[1,2,3,4,5,6,7])
f_list = [i for i in f]
print(f_list)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python数据类型拓展随记]]></title>
        <id>https://chloeeew.github.io/post/python-shu-ju-lei-xing-tuo-zhan-sui-ji/</id>
        <link href="https://chloeeew.github.io/post/python-shu-ju-lei-xing-tuo-zhan-sui-ji/">
        </link>
        <updated>2021-06-19T07:34:08.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-命名元组">1、命名元组</h1>
<ul>
<li>取元祖内部的元素都是同下标索引来进行取值的，比如一个元祖中包含了三个元素tu=('小明‘，18，’男‘)分别代表：姓名、年龄、性别<br>
通过下标取值不够人性化。</li>
</ul>
<h5 id="方法一可以做到类似像-字典一样取值">方法一：可以做到类似像 字典一样取值</h5>
<pre><code>tu=('小明‘，18，’男‘)
NAME=0
tu[NAME] # 获取姓名
</code></pre>
<h5 id="方法二我们可以用命名元组">方法二：我们可以用命名元组</h5>
<ul>
<li>collections模块中的namedtuple函数</li>
</ul>
<pre><code># namedtuple : 接收两个参数，第一个创建的类型名称，第二个是列表
from collections import namedtuple
Student = namedtuple('Student',['name','age','gender'])
s = Student('小明',18,'男')
print(s.name)
&gt;&gt;&gt; 小明
</code></pre>
<h1 id="2-推导式">2、推导式</h1>
<h2 id="列表推导式">列表推导式</h2>
<ul>
<li>需求：如何快速生成一个[&quot;data0&quot;,&quot;data1&quot;……,&quot;data99&quot;]的列表</li>
<li>[ 迭代中的每个元素（可二次加工）      for语句       条件判断（可有可无]</li>
<li>先写for循环语句，语句前面是结果，语句后面可以修饰迭代值（判断）</li>
<li></li>
</ul>
<pre><code>print([f&quot;data{i}&quot; for i in range(0,101) if i%2 == 0])

# 相当于
s = []
for i in range(0,101):
    if i % 2 == 0:
        s.append(&quot;data&quot; + str(i))
print(s)        
</code></pre>
<h2 id="字典推导式">字典推导式</h2>
<ul>
<li>在上面我们通过列表推导式可以快速生成列表，同样也可以快速生成</li>
</ul>
<pre><code># cookie中获取的字符串进行分割，形成对应字典
cookie_str = 'BSJIJ=fjiijijij;fjiewjfiw=nn922;jijiwf=0933;jiejfwo=wefewfv'

print({item.split('=')[0]:item.split('=')[1] for item in cookie_str.split(';')})
</code></pre>
<ul>
<li>推导式的注意事项：使用推导式是为了让代码简洁，但不代表代码越少就越好，推导式过于复杂会影响代码的可读性</li>
</ul>
<h2 id="生成器表达式">生成器表达式</h2>
<ul>
<li>以上在中括号使用推导式是列表推导式，大括号中使用推导式是字典推导式</li>
<li>那么小括号使用的推导式是什么？</li>
</ul>
<pre><code>gen_ = (item for item in range(0,100))
print(gen_)
# 打印的是一个生成器
&gt;&gt;&gt;  &lt;generator object &lt;genexpr&gt; at 0x0000019C0EA7D820&gt;
</code></pre>
<ul>
<li>在小括号中使用推导式它有一个特殊的名字是生成器表达式</li>
<li>generator object，就是一个生成器对象</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[top和iftop看资源占用以及网络流量情况]]></title>
        <id>https://chloeeew.github.io/post/top-he-iftop-kan-zi-yuan-zhan-yong-yi-ji-wang-luo-liu-liang-qing-kuang/</id>
        <link href="https://chloeeew.github.io/post/top-he-iftop-kan-zi-yuan-zhan-yong-yi-ji-wang-luo-liu-liang-qing-kuang/">
        </link>
        <updated>2021-05-22T08:55:57.000Z</updated>
        <content type="html"><![CDATA[<h1 id="top命令">top命令</h1>
<ul>
<li><em>top常用的性能分析工具，实时显示系统中各进程的资源占用状况，用q退出</em></li>
<li>从图中可以分为两个部分来看，上面是总体的情况，下面是每个进程CPU和内存的占用情况<br>
<img src="https://chloeeew.github.io/post-images/1628067376948.png" alt="" loading="lazy"></li>
</ul>
<h3 id="第一行-系统运行时间及负载">第一行 系统运行时间及负载</h3>
<ul>
<li>当前系统时间、up 多少days 多少min 服务器已经启动了多长时间（服务器稳定性的查看点，可以看服务器多长时间没有自动重启了）</li>
<li>2 users当前有多少人通过客户端连接到这台服务器上（1个人可以用多个客户端上登录，就显示多少个用户）</li>
<li>load average当前服务器1分钟、5分钟、15分钟运行压力平均负载（功能测试时候，发起请求服务器很长时间没有返回，网站很卡）
<ul>
<li>1分钟值高证明当前要处理的请求多</li>
<li><em>当前显示页面按下1</em>可以显示处多少当前有多少个CPU（第三行%Cpu会显示，例如%Cpu0就是单核，这样再去判断压力负载情况，load average的值和核数成正相关，如果核数高load average的值高一点也正常（4核-平均负载0.8--正常--1个核都没完全用上，1核--平均负载0.8--异常）</li>
</ul>
</li>
</ul>
<h3 id="第二行-task进程">第二行 Task进程</h3>
<ul>
<li>一共有多少个进程</li>
<li>正在运行的进程</li>
<li>睡眠的进程</li>
<li>停止了的进程</li>
<li>僵尸进程</li>
</ul>
<h3 id="第三行cpu整体情况">第三行CPU整体情况</h3>
<ul>
<li>us（user space用户空间占用的cpu百分比）</li>
<li>sy（系统内核占用cpu的百分比）</li>
<li>ni （进程优先级改变占cpu百分比）----在下方进程表中看NI值，如果有数值证明进程正在改变优先级（插队）</li>
<li>id（空闲cpu百分比）---服务器有多少CPU处于空闲，服务器没什么压力，值越大越好</li>
<li>wa（IO等待占用cpu百分比）</li>
<li>hi（hardware IRQ硬中断占用百分比--意外中断）</li>
<li>si（软中断---自主中断）</li>
<li>st（hypervisor管理程序占用百分比）
<ul>
<li><em>按下t，可以知道整体cpu的使用情况</em></li>
</ul>
</li>
</ul>
<h3 id="第四-五行-内存使用情况">第四、五行 内存使用情况</h3>
<ul>
<li>内存总量、空闲内存总量、缓存的总量</li>
<li>swap交换分区
<ul>
<li><em>按下m可以知道内存使用百分比</em></li>
</ul>
</li>
</ul>
<h3 id="下方进程状态行">下方进程状态行</h3>
<ul>
<li>PR：优先级（PR越小优先级越高）</li>
<li>VIRT：虚拟内存使用量</li>
<li>RES：使用物理内存</li>
<li>SHR：共享内存大小</li>
<li>TIME+：占用CPU总时长</li>
<li>%cpu：cpu使用率</li>
<li>%mem：内存使用率</li>
<li>COMMAND：命令/进程</li>
</ul>
<hr>
<h1 id="iftop命令">iftop命令</h1>
<ul>
<li>可以知道网络流量情况</li>
<li>是实时的流量工具<br>
<img src="https://chloeeew.github.io/post-images/1628067401439.png" alt="" loading="lazy"></li>
</ul>
<h3 id="安装">安装</h3>
<ul>
<li>iftop不能直接使用，需要安装</li>
</ul>
<pre><code>yum install -y iftop
</code></pre>
<h3 id="各字段代表含义">各字段代表含义</h3>
<ul>
<li>=&gt;代表发送数据</li>
<li>&lt;=代表接收数据</li>
<li>TX：发送</li>
<li>RX：接受</li>
<li>TOTAL：全部的流量</li>
<li>cum：目前累积流量</li>
<li>peak：峰值流量</li>
<li>rates：平均值，2秒，10秒，40秒的平均流量</li>
<li>t 切换显示状态，接受、发送数据</li>
<li>p 显示端口</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python 迭代器和生成器随记]]></title>
        <id>https://chloeeew.github.io/post/python-die-dai-qi-he-sheng-cheng-qi-sui-ji/</id>
        <link href="https://chloeeew.github.io/post/python-die-dai-qi-he-sheng-cheng-qi-sui-ji/">
        </link>
        <updated>2021-05-22T07:34:44.000Z</updated>
        <content type="html"><![CDATA[<h1 id="迭代器">迭代器</h1>
<h2 id="迭代协议">迭代协议</h2>
<ul>
<li>迭代协议：对象定义了一个__iter__方法的</li>
<li>可迭代对象iterable：能够使用for循环进行遍历的，该对象能够进行for循环或map函数等等
<ul>
<li>其内部实现了一个迭代协议：实现方式：对象内部定义了一个__iter__()方法（只要有这个方法就实现了迭代协议<br>
常见的可迭代对象有list、str、tuple</li>
</ul>
</li>
</ul>
<pre><code># 判断是否为可迭代对象：
dir(list) # 查看是否有__iter__
hasattr(list,'__iter__')
</code></pre>
<h2 id="迭代器协议">迭代器协议</h2>
<h4 id="迭代器是特殊的可迭代对象">迭代器是特殊的可迭代对象</h4>
<ul>
<li>迭代器对象还实现了__next__方法（迭代器除了有__iter__属性还有 __next__是属性）</li>
<li>迭代器可以被for迭代，for迭代迭代器时，会执行__next__方法</li>
<li>核心：通过__next__方法记住迭代的位置，有没有迭代完毕</li>
<li>__next__方法需要在值取完的时候，抛出StopIteration的错误信息<br>
所有的可迭代对象都可以转化为迭代器</li>
</ul>
<pre><code>迭代器 = iter(可迭代对象)

# 例子
li = [1,2,3,4,5]
li_iterator = iter(li)
print(li_iterator)

# 运行结果
&lt;list_iterator object at 0x000001F4A9F292B0&gt;
</code></pre>
<h4 id="迭代器与可迭代对象的区别">迭代器与可迭代对象的区别</h4>
<ul>
<li>区别是迭代器可以使用内置的next函数</li>
</ul>
<pre><code>print(next(li_iterator))
print(next(li_iterator))
print(next(li_iterator))
print(next(li_iterator))
print(next(li_iterator))

# 运行结果
1
2
3
4
5
</code></pre>
<p>注意点：当使用next获取完迭代器中所有的元素后，再次使用next进行迭代会抛出迭代器停止的异常</p>
<h4 id="迭代器实现思想可迭代对象">迭代器实现思想（可迭代对象）</h4>
<pre><code>class Next:
    def __init__(self,stop,start=-1):
        self.start = start
        self.stop = stop

    def __next__(self):
        if self.start &gt;= self.stop-1:
            raise StopIteration
        self.start += 1
        return self.start

class MyRange:
    def __init__(self,stop):
        self.stop = stop

    def __iter__(self):
        return Next(self.stop)


if __name__ == &quot;__main__&quot;:
    print([i for i in MyRange(10)])
    
# 运行结果
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>注意：从以上可以看出来，__iter__方法要求返回值必须有__next__方法</p>
<ul>
<li>而传统的range实现原理如下：</li>
</ul>
<pre><code>def range_test(stop):
    start = 0
    result = []
    while start &lt; stop:
        result.append(start)
        start += 1
    return result    
</code></pre>
<h3 id="迭代器使用场景及使用迭代器有什么好处">迭代器使用场景及使用迭代器有什么好处？</h3>
<p>在大批量存储数据的时候，迭代器可以帮助我们节约内存，需要的时候才会生成这个数<br>
例如，一个列表中有1w个数据，那它要把这1w数据都存下来，[1,2,3,....10000],它占用的内存空间比较大。</p>
<ul>
<li><strong>总结：迭代器的特点有延迟生成数据，节省内存</strong></li>
</ul>
<p>手工创建迭代器类，可继承Iterator对象，然后再写__next__方法。但显示生成不需要去写</p>
<pre><code>from collections.abc import Iterator
# 或者是以下（推荐）
from typing import Iterator
</code></pre>
<h1 id="生成器">生成器</h1>
<ul>
<li>生成器是特殊的迭代器（既实现了迭代协议、迭代器协议和生成器协议）</li>
<li>生成器内部存储的是数据存储的规则，不会保存具体的数据</li>
</ul>
<h3 id="为什么要有生成器">为什么要有生成器？</h3>
<ul>
<li>因为迭代器手工实现比较麻烦，所以python提供了生成器对象。生成器的目的就是获得迭代器（快速获得函数__next__和__iter__方法）（非常高效）</li>
</ul>
<h3 id="如何创建生成器">如何创建生成器</h3>
<ul>
<li>方式一：生成器表达式</li>
</ul>
<pre><code>gen_ = (item for item in range(0,100))
</code></pre>
<ul>
<li>方式二：生成器函数
<ul>
<li>只要函数中带有yield关键字就不再是一个普通的函数，而是生成器函数，这种生成器函数被调用后返回的是一个生成器对象</li>
<li>yield是一个关键字，他能记住函数执行的状态，保存状态、恢复状态（有点类似return但又不同）</li>
</ul>
</li>
</ul>
<pre><code>def gen():
    print(&quot;test1&quot;)
    for i in range(10):
        yield i
        print(&quot;test2&quot;)

g = gen()
print(g)
# 运行结果
&lt;generator object gen at 0x000001AE90E7D820&gt;
# 函数中的前后两个print都没有输出

next(g)
next(g)
print(next(g))
# 运行结果
test1
test2
test2
2
# 执行顺序：第一个next先print出test1，遇到yield就终止，
第二个next从print test2开始，然后经过for循环，遇到yield又终止了
第三个next从print test2开始，然后经过for循环，遇到yield又终止了，返回yield的数据i此时根据for循环i已经等于2
</code></pre>
<h2 id="生成器send方法">生成器send方法</h2>
<ul>
<li>作用
<ul>
<li>能和生成器内部进行数据交互（有next方法的作用，又多个传数据的功能），可以通过传递数据控制生成指定规则的数值</li>
</ul>
</li>
<li>调用send方法之前，要执行一次next
<ul>
<li>执行next可以使得函数停止在yield中，等调用send后，就在yeild中开始传递值</li>
</ul>
</li>
</ul>
<pre><code>def gen():
    for i in range(10):
        s = yield i
        print(f&quot;what I've receive is {s}&quot;)


g = gen()
print(next(g))
print(g.send(200))
print(g.send(300))
print(g.send(400))

# 运行结果
0
what I've receive is 200
1
what I've receive is 300
2
what I've receive is 400
3

# 运行顺序：第一个print next返回循环的第一个值0，
第二个print send给生成器函数通过yield传递了值200进去，输出200。然后执行循环到第二个值1，函数暂停，返回1，print出1

</code></pre>
<h2 id="生成器close方法">生成器close方法</h2>
<p>关闭生成器，会把该生成器内部的资源的清除（包括生成器yield的位置还有一些局部变量）</p>
<pre><code>g = gen()
g.close()
</code></pre>
<h2 id="生成器throw方法">生成器throw方法</h2>
<p>往生成器内部发送异常</p>
<pre><code>g.throw(ValueError,'主动抛出的异常')
</code></pre>
<h1 id="总结">总结</h1>
<h2 id="生成器和迭代器的区别">生成器和迭代器的区别？</h2>
<ul>
<li>生成器是特殊的迭代器，两者都属于可迭代对象</li>
<li>生成器相比迭代器多了三种方法：send(), close(),  throw()</li>
<li>包含关系：（可迭代对象（迭代器（生成器）））</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Postman完成RSA加密并使用加密所得鉴权]]></title>
        <id>https://chloeeew.github.io/post/postman-wan-cheng-rsa-jia-mi-bing-shi-yong-jia-mi-suo-de-jian-quan/</id>
        <link href="https://chloeeew.github.io/post/postman-wan-cheng-rsa-jia-mi-bing-shi-yong-jia-mi-suo-de-jian-quan/">
        </link>
        <updated>2021-05-06T13:03:38.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p>接口的鉴权方式除了token以外，还会遇到使用RSA加密和签名来处理的请求参数。在使用python完成接口自动化时，可以很方便的利用第三方库rsa，利用需要加密的字节信息和公钥对象用rsa.encrypt生成加密文本，从而得到我们所需要的加密后的信息。</p>
</li>
<li>
<p>postman相比python就稍微比较复杂了，因为postman作为接口测试工具，多数功能测试者在用，但postman本身不支持rsa加密，在pre-request-script中需要写一定的代码，且需要forgeJS协助。如果不懂代码，那建议寻求开发协助，或者一步步按照以下方式操作即可。</p>
</li>
</ul>
<hr>
<h3 id="解决方案">解决方案：</h3>
<ul>
<li>
<pre><code>在pre-requests-script中，添加forge模块代码到全局变量中，提取的全局变量（字符串类型）通过eval函数使其在当前环境中执行，利用模块中提供的生成公钥对象和加密方法加密。
</code></pre>
</li>
</ul>
<h3 id="本次加密得到的产出物设置到全局变量中">本次加密得到的产出物，设置到全局变量中：</h3>
<ol>
<li>token前50位+时间戳 ，加密后得到的sign</li>
<li>时间戳timestamp</li>
</ol>
<hr>
<h3 id="1-下载forge使用gitbash">1、下载forge（使用gitbash）</h3>
<pre><code>git clone https://github.com/digitalbazaar/forge.git
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://chloeeew.github.io/post-images/1627963730176.png" alt="" loading="lazy"></figure>
<h3 id="2-安装forge使用nmp">2、安装forge（使用nmp）</h3>
<pre><code>cd 到你gitbash下载的位置
npm install
</code></pre>
<p>注意事项：这步我没有报错，如果有报错信息请看一下是否有下载node</p>
<h3 id="3-在需要鉴权的接口请求的pre-request-script中设置">3、在需要鉴权的接口请求的pre-request-script中设置</h3>
<p>前提：token在登录接口中已经设置到全局变量中了<br>
注意事项：这里的公钥是需要项目开发提供（本文的公钥已做了脱敏处理）</p>
<pre><code>if(!pm.globals.has(&quot;forgeJS&quot;)){
    pm.sendRequest(&quot;https://raw.githubusercontent.com/loveiset/RSAForPostman/master/forge.js&quot;, function (err, res) {
        if (err) {
            console.log(&quot;hellworld&quot;)
            console.log(err);
            
        } else {
            pm.globals.set(&quot;forgeJS&quot;, res.text());
        }
    })
}
eval(postman.getGlobalVariable(&quot;forgeJS&quot;));
pm.globals.unset(&quot;variable_key&quot;);
pm.globals.set(&quot;variable_key&quot;, &quot;variable_value&quot;);
 
 
// 这里的公钥需要项目开发者提供（pem文件公钥）
const public_key = '-----BEGIN PUBLIC KEY-----\n' +
        'MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDQ5ENTu9Z1LprzedE\n' +
        'O3F7gs+7bzrgPsMl29LX8UoPYvIG8C604CprBQ4FkfnJp0WZyLq6sBr\n' +
        'tuPorOc42+gLnFfyhJAwdZB6SqWfDg7bW+jNe5K555555lEMGo8Dg+S\n' +
        'kKlZFc8Br7SHtbL2tQIDAQAB\n' +
        '-----END PUBLIC KEY-----'
 
var publicKey = forge.pki.publicKeyFromPem(public_key);//公钥
var timestamp = Math.round(new Date().getTime()/1000);//时间戳
var token = pm.environment.get(&quot;token&quot;)
var tempStr = token.substring(0,50)+timestamp //拼接的token+时间戳
 
//rsa加密得到签名
var sign = forge.util.encode64(publicKey.encrypt(tempStr,'RSAES-PKCS1-V1_5',{md:forge.md.sha1.create(),mgf: forge.mgf.mgf1.create(forge.md.sha1.create())}));
 
//将得到的产物设置到全局变量中
pm.environment.set(&quot;timestamp&quot;,timestamp)
pm.environment.set(&quot;sign&quot;,sign)
</code></pre>
<hr>
<p>本人CSDN中有相同文章：https://blog.csdn.net/weizhi3320/article/details/117903607</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python自动化测试-eval后数字运算得到无限小数]]></title>
        <id>https://chloeeew.github.io/post/python-zi-dong-hua-ce-shi-eval-hou-shu-zi-yun-suan-de-dao-wu-xian-xiao-shu/</id>
        <link href="https://chloeeew.github.io/post/python-zi-dong-hua-ce-shi-eval-hou-shu-zi-yun-suan-de-dao-wu-xian-xiao-shu/">
        </link>
        <updated>2021-03-12T14:47:07.000Z</updated>
        <content type="html"><![CDATA[<h3 id="项目的自动化测试用例中数据库某条金额数据查询预期结果是查询前多200001元">项目的自动化测试用例中，数据库某条金额数据查询预期结果是查询前多2000.01元</h3>
<p>譬如：测试该用例前做了前置sql查询获取金额为5000元，我的测试用例是增加2000.01元，预期执行用例后，在数据库查询到的金额应该为7000.01元（#money#+2000.01)</p>
<p>对于这种用例的处理原本只是获取前置sql查询的内容，来替换#money#值，通过eval()来进行字符串转数字 以及 运算操作</p>
<p>但实际通过eval后得到的7000.00999999999的无限小数，导致断言失败<br>
<img src="https://chloeeew.github.io/post-images/1627962616221.png" alt="" loading="lazy"></p>
<p>这是因为我们在运算的时候没有确定尾数导致，python会把我们的数据都先转换成二进制，然后再进行计算，例如<mark>经典的0.1+0.2并不等于0.3而是0.30000000004</mark></p>
<pre><code>Python 3.9.1 (tags/v3.9.1:1e5d33e, Dec  7 2020, 17:08:21) [MSC v.1927 64 bit (AMD64)] on win32
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; print(0.1+0.2)
0.30000000000000004
&gt;&gt;&gt; 0.1+0.2
0.30000000000000004
</code></pre>
<h3 id="如何解决">如何解决？</h3>
<p>我们可以在用例excel中把原本的expected:#money#+2000.01更改为round(#money#+2000.01,2)在代码除eval后，就会将计算得到的数据四舍五入并保留两位小数得到我们期待的<br>
<img src="https://chloeeew.github.io/post-images/1627962623799.png" alt="" loading="lazy"><br>
<img src="https://chloeeew.github.io/post-images/1627962628765.png" alt="" loading="lazy"></p>
<p>本人CSDN有相同文章：https://blog.csdn.net/weizhi3320/article/details/118674484</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[🔆Gridea+Github+域名：搭建一个属于自己的博客网站]]></title>
        <id>https://chloeeew.github.io/post/grideagithubyu-ming-da-jian-yi-ge-shu-yu-zi-ji-de-bo-ke-wang-zhan/</id>
        <link href="https://chloeeew.github.io/post/grideagithubyu-ming-da-jian-yi-ge-shu-yu-zi-ji-de-bo-ke-wang-zhan/">
        </link>
        <updated>2020-08-29T06:07:43.000Z</updated>
        <content type="html"><![CDATA[<p><em>在搜索引擎学习逛博客或者搜问题的时候，发现很多人都不在用广告满天飞的某DN，也不喜欢用排版难看的某圆，而是用自己的域名搭了属于自己的博客，这让我非常心动，前些日子也自己按照一些“教程”搭了一个，发现里面的小坑挺多的，而这些教程都没有清晰说明，今天趁稍微有空，写一下</em></p>
<h1 id="一-gridea生成静态网页">一、Gridea生成静态网页</h1>
<ul>
<li>它可以让你不需要写前端就能生成一个漂亮的带样式的静态网页，能够跟github博客集成到一起，除了Gridea还有其他的（抱歉又忘了名字），但需要自己去搭服务，搞数据库，这流程太漫长了，所以综合考虑Gridea是最方便简单的<br>
<img src="https://chloeeew.github.io/post-images/1627974530187.png" alt="" loading="lazy"></li>
</ul>
<h3 id="1-下载客户端待用">1、下载客户端待用</h3>
<ul>
<li>网址：https://gridea.dev/</li>
<li>根据自己的操作系统下载客户端即可<br>
<img src="https://chloeeew.github.io/post-images/1627974495377.png" alt="" loading="lazy"></li>
</ul>
<h1 id="二-github创建仓库并授权给gridea">二、Github创建仓库并授权给Gridea</h1>
<h3 id="1-仓库命名">1、仓库命名</h3>
<ul>
<li>Repository name的命名规则
<ul>
<li>创建新的仓库后，命名为用户名.github.io</li>
</ul>
</li>
</ul>
<pre><code>username.github.io
</code></pre>
<h3 id="2-github给gridea">2、Github给Gridea</h3>
<ul>
<li>github 中 右上角Setting进入设置</li>
<li>菜单栏中找到Developer settings</li>
<li>选择Generate new token</li>
<li>新token命名随意，但需要把下方授权内容中repo所有项勾选<br>
生成了token之后一定要马上把生成码复制起来（忘了的话，删了重新创建token就可以了）<br>
<img src="https://chloeeew.github.io/post-images/1627974556144.png" alt="" loading="lazy"></li>
</ul>
<h3 id="3-token密钥给到gridea">3、token密钥给到Gridea</h3>
<ul>
<li>如图，填写后保存并且按检测远程连接</li>
<li>连接成功后，点击左下角的同步<br>
<img src="https://chloeeew.github.io/post-images/1627974575803.png" alt="" loading="lazy"></li>
</ul>
<h3 id="三-腾讯云购买域名">三、腾讯云购买域名</h3>
<ul>
<li>https://dnspod.cloud.tencent.com/
<ul>
<li>只要名字够特别，域名10年都不贵</li>
</ul>
</li>
</ul>
<h4 id="注意事项">注意事项</h4>
<ol>
<li>购买前要在腾讯云实名认证</li>
</ol>
<h3 id="四-腾讯云dns服务器添加记录">四、腾讯云DNS服务器添加记录</h3>
<ul>
<li>右上角控制台-&gt; DNS解析DNS pod -&gt;域名解析列表-&gt;点击刚刚购买的域名-&gt;添加记录</li>
</ul>
<h4 id="注意事项-2">注意事项</h4>
<p>1、主机记录和记录类型以及记录值要按照图的顺序一一填写，切勿错乱<br>
2、第二行IPv4要自行在cmd上ping一下（username是自己的用户名），ping通后能得到对应的服务器ip地址<br>
3、配置好记录后，DNS解析需要一定时间</p>
<pre><code>ping username.github.io
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://chloeeew.github.io/post-images/1627974621739.png" alt="" loading="lazy"></figure>
<h3 id="五-将域名填写到gridea-远程-cname中">五、将域名填写到Gridea-&gt;远程-&gt;Cname中</h3>
<ul>
<li>如第二步第三小节图，填写后重新按一下保存+检测远程连接+同步<br>
<img src="https://chloeeew.github.io/post-images/1627974575803.png" alt="" loading="lazy"></li>
</ul>
<h3 id="六-在github中为博客加上ssl">六、在github中为博客加上SSL</h3>
<ol>
<li>回到github的io项目中，选择项目setting</li>
<li>选择菜单中的Pages中拉到最下方，勾选ENFORCE HTTPS<br>
<img src="https://chloeeew.github.io/post-images/1627974629586.png" alt="" loading="lazy"></li>
</ol>
<h3 id="七-最后的检测域名现状">七、最后的检测域名现状</h3>
<ul>
<li>https://zijian.aliyun.com</li>
<li>填写自己的域名，如果能满足以下检查点，说明已经搭建好了</li>
</ul>
<h4 id="检查点">检查点</h4>
<ol>
<li>DNS检查：域名递归解析正常</li>
<li>网站检查：<br>
3. Ping检查正常<br>
4. 网站状态码正常<br>
5. 网站不在工信部黑名单<br>
5. <strong>网站服务器在国外，所以不需要备案</strong></li>
<li>域名检查：域名状态和有效期正常</li>
</ol>
<h3 id="最后最后再说一遍的注意事项">最后最后再说一遍的注意事项</h3>
<ol>
<li>DNS记录不能把CNAME和@乱序了！！</li>
<li>一开始配置好的内容，需要一点时间让它去解析，切勿急躁</li>
<li>如果按照这个步骤还有任何问题，请联系～</li>
</ol>
]]></content>
    </entry>
</feed>